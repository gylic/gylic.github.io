<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/11/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<a id="more"></a></p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>线性表的两个应用</title>
    <url>/2020/05/04/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h2 id="一约瑟夫问题">一、约瑟夫问题</h2>
<h3 id="作业题">1.1 作业题</h3>
<p><strong>问题描述：</strong>n 个人围成一个圆圈，从第s个人开始顺时针报数, 报到m 的人出列。然后再从下一 个人开始，从 1 顺时针报数，报到m 的人出列，…，如此下去直到这些人全部出列。</p>
<p><strong>用到：</strong>单向循环链表。</p>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> #include &lt;iostream&gt;
 using namespace std;
 struct Node &#123;
    int data;
    Node *link;
    Node (int d&#x3D;0,Node *next&#x3D;NULL ):data(d), link(next) &#123; &#125;;
 &#125;;
 
class Josephus &#123;	
 private: 	
     Node *first;&#x2F;&#x2F;循环链表的头节点
     int    n;     &#x2F;&#x2F;链表节点个数
     int    s;     &#x2F;&#x2F;第一个报数人的序号
     int    m;     &#x2F;&#x2F;报数出局的数
 
 public:	
 	void createList();
    void outputList();
    Josephus(int N, int S, int M):n(N),s(S),m(M)
    &#123;
        createList();
        outputList();
    &#125;
 
 &#125;;
 
 void Josephus::createList()
 &#123;
     Node *pre &#x3D; NULL;
     Node *cur &#x3D; NULL;
     Node *p &#x3D; new Node(1);
     first &#x3D; p;
     cur &#x3D; p;
    for (int i&#x3D;2; i&lt;&#x3D;n; i++)
    &#123;
         p &#x3D; new Node(i);
         pre &#x3D; cur;
         cur &#x3D; p;
		 pre-&gt;link &#x3D; cur;
    &#125;
    cur-&gt;link &#x3D; first;    
    
 &#125;
 
 void Josephus::outputList()
 &#123;
     Node *pre &#x3D; NULL;
     Node *cur &#x3D; first;
     s--;
     while (s--)            &#x2F;&#x2F;寻找第K个人（开始报数的人）
     &#123;
        pre &#x3D; cur;
        cur &#x3D; cur-&gt;link;
     &#125;
     while (n--)            &#x2F;&#x2F;输出链表中所有的结点值
     &#123;
        int y &#x3D; m-1;
        while (y--)            &#x2F;&#x2F;寻找报m的人
        &#123;
            pre &#x3D; cur;
            cur &#x3D; cur-&gt;link;
        &#125;
        Node *p &#x3D; cur;
        cout &lt;&lt; p-&gt;data &lt;&lt; &quot;,&quot;;
        cur &#x3D; cur-&gt;link;    &#x2F;&#x2F;删除节点的过程
        pre-&gt;link &#x3D; cur;
        delete p;
        p&#x3D;NULL;
     &#125;
 &#125;
 
 int main()
 &#123;
 	int n,s,m;
 	cout&lt;&lt;&quot;请输入n、s、m:&quot; &lt;&lt;endl;
    cin&gt;&gt;n&gt;&gt;s&gt;&gt;m;
	cout&lt;&lt;&quot;出局顺序:&quot;&lt;&lt;endl; 
    Josephus clist(n,s,m);
    return 0;
&#125;</code></pre>
<h3 id="相似问题其一">1.2 相似问题其一</h3>
<p><strong>问题描述：</strong>有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡是报到3的人退出圈子，问最后留下的是原来的几号。</p>
<p><strong>用到：</strong>数组。</p>
<p><strong>以下是书上给出的代码：</strong>不过我没能运行成功。原因：杀毒软件说它是病毒然后给我拦截了。😂</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#define nmax 50
using namespace std;
int main()
 &#123;
	int i,k,m,n,num[nmax],*p;
	cout&lt;&lt;&quot;please input the total of numbers:&quot;;
	cin&gt;&gt;n;
	p&#x3D;num;
	
	for(i&#x3D;0;i&lt;n;i++)
	*(p+i)&#x3D;i+1;
	
	i&#x3D;0;&#x2F;&#x2F;累计参与游戏的人员位置
	k&#x3D;0;&#x2F;&#x2F;累计报数值
	m&#x3D;0;&#x2F;&#x2F;累计退出的人数
	
	while(m&lt;n-1) 
  &#123; 
		
    if(*(p+i)!&#x3D;0)k++;
    if(k&#x3D;&#x3D;3)
	&#123;
	*(p+i)&#x3D;0;
	k&#x3D;0;&#x2F;&#x2F;报数值回归0
    m++;&#x2F;&#x2F;累加退出的人数 
    &#125;
      i++;
      if(i&#x3D;&#x3D;n)i&#x3D;0;	&#x2F;&#x2F;当到达最后一个人时赋值回到0，保证形成环状
  &#125;
    while(*p&#x3D;&#x3D;0)p++;
    cout&lt;&lt;*p&lt;&lt;&quot;is left&quot;&lt;&lt;endl;
    return 0;
 &#125; 
 &#x2F;*运行结果如下：
 please input the total of numbers:23
 8 is left*&#x2F; </code></pre>
<h3 id="相似问题其二">1.3 相似问题其二</h3>
<p><strong>问题描述：</strong>n个人轮流报数，报到number的人出局，剩下的成环继续轮流报数，问最后剩下的是谁？（设此处n=12,number=3）</p>
<p><strong>用到：</strong>Vector类的函数： push back() 在向量尾部加入一个元素 at() 获取对应索引的元素(也可使用 [] 访问) size() 获取当前vector内的元素个数 begin() 返回向量头的迭代器 erase() 删除对应迭代器对应的元素 删除当前向量中的第i个元素写法为: erase(v.begin()+i ) 迭代器此处不深入讲解，知道如何删除第1个元素即可。</p>
<p><strong>分析:</strong></p>
<p>n个人——向量初始容量为n</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v;&#x2F;&#x2F;创建一个向量容器
const int n&#x3D;12;
const int number&#x3D;3;</code></pre>
<p>number——每次跳跃距离</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;设i是计算好的下标
&#x2F;&#x2F;可以准确地删除已出局的人
v.erase(v.begin()+i);</code></pre>
<p>剩下的成环——取余成环</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">i&#x3D;(i+number-1)%v.size();</code></pre>
<p><strong>代码如下（来自本校某大佬）</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
int main()
&#123;
	vector&lt;int&gt; v;&#x2F;&#x2F;创建一个向量容器
	const int n&#x3D;12;
	const int number&#x3D;3;
	for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;
	v.push_back(i);&#x2F;&#x2F;循环初始，给玩家编号	
	&#125; 
	int i&#x3D;0;
	while(v.size()!&#x3D;1) &#123;&#x2F;&#x2F;当只剩下一个人的时候结束 
	i&#x3D;(i+number-1)%v.size();&#x2F;&#x2F;取余成环，计算下一个出局的人的位置	
	v.erase(v.begin()+i);&#x2F;&#x2F;剔除出局的人		
	&#125;
	cout&lt;&lt;v[0]&lt;&lt;endl;&#x2F;&#x2F;获得最后一个人 
	return 0; 
&#125;</code></pre>
<h2 id="二单向链表逆序">二、单向链表逆序</h2>
<p><strong>问题描述：</strong>设有一个表头指针为h的单链表。试设计一个算法，通过遍历一趟链表，将链表中所有结点的链接方向逆转。要求逆转结果链表的表头指针h指向原链表的最后一个结点。</p>
<p><strong>用到：</strong>单向链表</p>
<p><strong>代码如下：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
 
struct List
&#123;
	int   data;
	List *next;
&#125;;
 
List* createList(int n)       &#x2F;&#x2F;创建含有n个节点的单链表
&#123;
	List *head, *p, *cur;
	cur&#x3D;head &#x3D; NULL;   &#x2F;&#x2F;初始化表头和中间指针
	int i;
	for (i &#x3D; n; i &gt; 0; --i)
	&#123;
		p &#x3D; new List;     &#x2F;&#x2F;申请空间，创建第一个节点
		cin &gt;&gt; p-&gt;data;      &#x2F;&#x2F;往节点中存入数据信息
		if (head &#x3D;&#x3D; NULL)
		&#123;
			head &#x3D; p;
		&#125;
		else
		&#123;
			cur-&gt;next &#x3D; p;
		&#125;
		cur &#x3D; p;
	&#125;
	cur-&gt;next &#x3D; NULL;
	return head;
&#125;
 
List *ReverseList(List *head)          &#x2F;&#x2F;逆置单链表
&#123;
	List *p, *r;       &#x2F;&#x2F;定义两个中间节点，用于顺移逆置链表节点
	if (head-&gt;next &#x3D;&#x3D; NULL)
		return head;
	p &#x3D; head;          &#x2F;&#x2F;获取头节点地址
	r &#x3D; p-&gt;next;       &#x2F;&#x2F;获取链表第二个节点地址
	p-&gt;next &#x3D; NULL;    &#x2F;&#x2F;头节点变为尾节点，原链表表头指向空
	while (r)
	&#123;
		p &#x3D; r;
		r &#x3D; r-&gt;next;
		p -&gt;next &#x3D; head;   &#x2F;&#x2F;使第二个节点指向原先的头节点
		head &#x3D; p;          &#x2F;&#x2F;使第二个节点变为头节点，用于循环逆置
	&#125;
	return head;
&#125;
 
void print(List *head)        &#x2F;&#x2F;输出逆置后的单链表
&#123;
	List *p;
	p &#x3D; head;
	while (p)
	&#123;
		cout&lt;&lt;p-&gt;data;
		p &#x3D; p-&gt;next;
		cout &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
&#125;
int main()
&#123;
	List *p, *q;
	cout &lt;&lt; &quot;请输入单链表的节点个数：&quot;;
	int n;
	cin &gt;&gt; n;
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;创建一个节点为&quot; &lt;&lt; n &lt;&lt; &quot;的单链表&quot; &lt;&lt; endl;
	p &#x3D; createList(n);
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;这步为程序逆置单链表&quot; &lt;&lt; endl;
	q &#x3D; ReverseList(p);
	cout &lt;&lt; endl;
	cout &lt;&lt; &quot;打印逆置后的单链表&quot; &lt;&lt; endl;
	print(q);
	cout &lt;&lt; endl;
	return 0;
&#125;
&#x2F;*说明：
输入要求：先输入要创建的节点个数。再分别输入各节点的数据域。
输出：逆序后的各节点的数据域。*&#x2F;
</code></pre>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构笔记</title>
    <url>/2020/06/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<p>[toc]</p>
<p><strong>题型：</strong> 分析题30 简答题40 应用题30 (写程序10分) .</p>
<p>今年比较特殊，好像题比往年简单，然而我还是感到头秃。</p>
<h2 id="第1章">第1章</h2>
<p><strong>计算时间复杂度</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200619194856960-363594173.png" /></p>
<p><strong>注意：</strong></p>
<p>一个语句本身的程序步数可能不等于该语句一次 执行所具有的程序步数。<br />
例如：赋值语句 x = sum (R, n) 赋值操作的程序步数为 1；<br />
一次执行对函数 sum (R, n) 的调用需要的程序步 数为 2 * n+3； 一次执行的程序步数为 1+2 * n+3 = 2 * n+4</p>
<p><strong>大O的表示方法</strong></p>
<p>T(n) = O(f(n)) 称f(n)为算法的“渐进”时间复杂度 ,简称时间复杂度，以简化算法复杂性的分析。 说明：在计算算法时间复杂度时，可以忽略所有低次幂和最高次幂的系数。</p>
<p><strong>大O的运算规则</strong></p>
<p>• 加法准则(并列程序段 )<br />
前提：<span class="math inline">\(T_1\)</span>(m) = O(f(m)); <span class="math inline">\(T_2\)</span>(n) = O(g(n))<br />
结论：<span class="math inline">\(T\)</span>(n)= <span class="math inline">\(T_1\)</span>+<span class="math inline">\(T_2\)</span> = O(f(n)+g(n))<br />
<span class="math inline">\(T\)</span>(n) = <span class="math inline">\(T_1\)</span>+<span class="math inline">\(T_2\)</span> = O(max(f(m),g(n)))</p>
<p>• 乘法准则(嵌套程序段)<br />
前提：<span class="math inline">\(T_1\)</span>(n) = O(f(n)); <span class="math inline">\(T_2\)</span>(n) = O(g(n))<br />
结论：<span class="math inline">\(T\)</span>(n) = <span class="math inline">\(T_1\)</span>* <span class="math inline">\(T_2\)</span> = O(f(n)*g(n))</p>
<p><strong>常见函数的增长率</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200619194940245-829728112.png" /></p>
<p><strong>例1</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void exam ( float x[ ][ ], int m, int n ) &#123;      
  float sum [ ];      
  for ( int i &#x3D; 0; i &lt; m; i++ ) &#123; &#x2F;&#x2F;x中各行          
     sum[i] &#x3D; 0.0; &#x2F;&#x2F;数据累加          
     for ( int j &#x3D; 0; j &lt; n; j++ )       
         sum[i] +&#x3D; x[i][j];      
  &#125;      
  for ( i &#x3D; 0; i &lt; m; i++ )  &#x2F;&#x2F;打印各行数据和          
     cout &lt;&lt; i &lt;&lt; “ : ” &lt;&lt;sum [i] &lt;&lt; endl;  
&#125;         
&#x2F;&#x2F;渐进时间复杂度为 O(max (m*n, m))</code></pre>
<p><strong>例2</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void bubble_sort(int a[], int n ) &#123; 
&#x2F;&#x2F;用冒泡排序方法，将a 中n个整数的序列排列成自小至大有序的整数序列。  
    int change ,i; 
    for (i &#x3D; n-1,change&#x3D;1; i &gt;&#x3D;1&amp;&amp;change; - -i )&#123;     
        change&#x3D; 0;    
        for (j &#x3D; 0; j&lt;i; ++j )     
        if (a [j] &gt;a[ j+1]) &#123;           
           a [j]&lt;-&gt;a[ j+ 1]                     
           change&#x3D;1;&#125;         
               &#125; 
&#125;&#x2F;&#x2F; bubble_sort

&#x2F;&#x2F;基本操作：赋值操作。时间复杂度：O(n^2)--最坏情况下时间复杂度 </code></pre>
<p>BubbleSort n-1趟 BubbleExchange ( ) n-i次比较</p>
<p>当输入的数据已经排好序， 只要比较n-1次， 当输入的数据是减序，需要 比较n(n-1)/2次。</p>
<p><strong>递归时间复杂度分析</strong>、</p>
<p>104 hanoi</p>
<h2 id="第23章">第2、3章</h2>
<p><strong>线性结构:</strong></p>
<p>1.栈和队列</p>
<p>栈pop，push 91</p>
<p>队列原理115，Enqueue，Dequeue117</p>
<p>2.栈序列</p>
<p>卡特兰数另类递推式： h(n)=h(n-1) * (4*n-2)/(n+1);</p>
<p>3.栈、队列的边界条件</p>
<p>初始top=-1，最大top=maxsize-1</p>
<p>初始front=rear=0，最后（rear+1）%maxsize == front队满，front== rear队空。</p>
<p>4.双向循环链的基本操作</p>
<p>搜索71，插入72，删除73</p>
<p>双向循环链表中，P指针所指向的结点的前驱指针域和后继指针域分别用prior和next表示，删除P指针所指向的结点，则其基本操作为p-&gt;prior-&gt;next=p-&gt;next, p-&gt;next-&gt;prior=p-&gt;prior, free(p)。</p>
<p>5.循环队列的判空判满操作</p>
<p>请描述在循环队列中，（队列用Q表示，队头和队尾指针分别由front和rear表示，该队列有MS个存储空间），判断队空和队满的条件分别分：Q.front== Q.rear, Q.front==（Q.rear+1）% MS 。</p>
<p><a href="https://www.cnblogs.com/gylic/p/12809962.html">数据结构第二章笔记</a></p>
<p><a href="https://www.cnblogs.com/gylic/p/12902165.html">数据结构第三章笔记</a></p>
<h2 id="第4章">第4章</h2>
<p><strong>一维数组求地址</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200619195041797-1722663588.png" /></p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200619195051213-2137226933.png" /></p>
<p>递推式 <span class="math inline">\(\begin{equation} LOC ( i ) = LOC ( i -1 ) + l =α+ i*l\end{equation}\)</span></p>
<p><strong>二维数组求地址</strong></p>
<p>n行m列的二维数组：</p>
<p><img src="https://img2020.cnblogs.com/blog/2023220/202006/2023220-20200619195142158-1259005485.png" /></p>
<p>行优先 <span class="math inline">\(LOC ( j, k ) = a + ( j * m + k ) * l\)</span></p>
<p><strong>n维数组</strong></p>
<p>各维元素个数为 <span class="math inline">\(m_1\)</span>, <span class="math inline">\(m_2\)</span>, <span class="math inline">\(m_3\)</span>, …, <span class="math inline">\(m_n\)</span></p>
<p>下标为 <span class="math inline">\(i_1\)</span>, <span class="math inline">\(i_2\)</span>, <span class="math inline">\(i_3\)</span>, …, <span class="math inline">\(i_n\)</span> 的数组元素的存储地址： <span class="math display">\[
\begin{align}
&amp;LOC ( i_1, i_2, …, i_n )\nonumber\\
&amp;= a + ( i_1* m_2* m_3* …* m_n + i_2* m_3* m_4* …* m_n+……+ i_{n-1}*m_n + i_n ) * l \nonumber\\
&amp;= a+(\sum_{j=1}^{n-1}i_j *\prod_{k=j+1}^{n}m_k+i_n) *l\nonumber
\end{align}
\]</span></p>
<p>例题：</p>
<p>有6行8列的二维数组A，每个元素用相邻的6个字节存储，存储器按字节编址，已知A的起始存储地址（基址）为1000，在行优先存储和列优先存贮情况下A[5,5]的存储地址分别为 1270 , 1210 。</p>
<h2 id="第5章"><strong>第5章</strong></h2>
<p><strong>树（要求代码）：</strong></p>
<p>树的特性(知道其推导过程) 树的遍历(深度和层次遍历及其应用)</p>
<p>199递归遍历；205层次遍历用到队列。</p>
<p>二叉树的建立(先根和后根序列确定一棵树)</p>
<p>202建树，208确定树</p>
<p>树和二叉树的转换 堆</p>
<p>235</p>
<p>哈夫曼树及编码</p>
<p>241，245</p>
<p><a href="https://www.cnblogs.com/gylic/p/13040922.html">数据结构第五章笔记</a></p>
<h2 id="第6章">第6章</h2>
<p><strong>集合：</strong></p>
<p>散列表:创建和冲突检测、查找长度( 成功和非成功)</p>
<p>、285</p>
<p><a href="https://www.cnblogs.com/gylic/p/13141930.html">数据结构第六章笔记</a></p>
<h2 id="第7章">第7章</h2>
<p><strong>搜索：</strong></p>
<p>折半搜索原理及适用条件</p>
<p>304</p>
<p>二叉判定树的结构</p>
<p>：本质是二叉排序树，中序遍历是有序的，二叉判定树的节点是下标或位置</p>
<p>二叉排序树的创建和删除</p>
<p>311</p>
<p><a href="https://www.cnblogs.com/gylic/p/13150961.html">数据结构第七章笔记</a></p>
<h2 id="第8章">第8章</h2>
<p><strong>图(掌握原理)：</strong></p>
<p>图的存储结构、</p>
<p>邻接矩阵、邻接表，逆邻接表。357</p>
<p>深度和广度序列</p>
<p>364-365</p>
<p>图(强)连通，(强)连通分量</p>
<p>367</p>
<p>最小生成树算法</p>
<p>kruskal先找分边、prim顺路贪心。371、373</p>
<p>最短路径和最短路径长度</p>
<p>dijkstra 绕弯贪心376</p>
<p>拓扑排序</p>
<p>384</p>
<p><a href="https://www.cnblogs.com/gylic/p/13150985.html">数据结构第八章笔记</a></p>
<h2 id="第9章">第9章</h2>
<p><strong>排序算法(掌握原理)</strong></p>
<p>直接插入、折半插入、希尔排序、冒泡、快排(重点)、简单选择、堆排序。</p>
<p>有一道经典例题。</p>
<p><a href="https://www.cnblogs.com/gylic/p/13151060.html">数据结构第九章笔记</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
